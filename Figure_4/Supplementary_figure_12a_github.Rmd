---
title: "Supplementary figure 12a"
author: "David Bradley"
date: "1/1/2021"
output: html_document
---

# GGplot font

```{r}

# https://stackoverflow.com/questions/27689222/changing-fonts-for-graphs-in-r

library(extrafont)

font_import()
loadfonts()       #Register fonts for Windows bitmap output
fonts() 

```

# The first step is to model the specificity of CK2

```{r}

library(stringr)
library(readr)
library(seqinr)
library(ggseqlogo)
library(gdata)

# Data comes from Bachmann et al., 2019 (https://www.biorxiv.org/content/10.1101/822668v3)

prot_mapper <- read_csv('export.csv')

# Kinases only

prot_mapper <- prot_mapper[unlist(prot_mapper[,5]) == TRUE,]

# Retrieve upstream kinase, substrate, and substrate position

ksr <- prot_mapper[,c(3,4,6,9,10)]

# We exclude KSRs that are supported only by the text-mining tools

curated <- c('psp','signor','pid','bel','reactome')

source_list <- strsplit(unlist(ksr[,5]),split=',')

number_curated <- lapply(source_list, function(x) length(intersect(x,curated)))

ksr <- ksr[which(number_curated > 0),]

# Correct formatting problems

for (i in 1:nrow(ksr)) {
 
  if(is.na(ksr[i,2])) {ksr[i,2] <- ksr[i,1]} 
  
}

# Retrieve CSNK2A1 and CSNK2A2 substrates

csnk2a1_ksr <- ksr[which(unlist(ksr[,2] == 'CSNK2A1') == TRUE),]
csnk2a2_ksr <- ksr[which(unlist(ksr[,2] == 'CSNK2A2') == TRUE),]
csnk2a_ksr <- unique(rbind(csnk2a1_ksr,csnk2a2_ksr)) 

hs_rp <- read.fasta('hs_proteome_uniprot.fasta', seqtype='AA')
hs_ids <- rapply(strsplit(names(hs_rp),split='\\|'),function(x) x[2])

# Retrieve the flanking sequences of the phosphosites

psite_vec <- NULL
index_vec <- NULL

for (i in 1:nrow(csnk2a_ksr)) {
  
  print(i)
  
  # Retrieve the first element only
  uniprot_id <- unname(unlist(csnk2a_ksr[i,3]))
  site_pos <- unname(unlist(csnk2a_ksr[i,4]))
  
  # Loop for ambiguous psite positions
  
  for (j in 1:length(uniprot_id)) {
    
    pos <- as.numeric(site_pos)
    
    # Substrate sequence
  
    sub_seq <- unlist(getSequence(hs_rp[hs_ids %in% uniprot_id[j]]))
    
    if (length(sub_seq) == 0) {next}
    
    # Phosphosite position
    
    if (pos < 8) {
      
      gap <- paste(rep('_',(8-pos)),collapse='')
      psite <- paste(sub_seq[1:(pos+7)],collapse='')
      psite <- paste(gap,psite,sep='')
      if (!substr(psite,8,8) %in% c('S','T','Y')) {next}
      psite_vec <- c(psite_vec, psite)
      index_vec <- c(index_vec, i)
      
    } else if ((pos+7) > length(sub_seq)) {
      
      psite <- paste(sub_seq[(pos-7):(length(sub_seq))],collapse='')
      gap <- paste(rep('_',(pos+7)-length(sub_seq)),collapse='')
      psite <- paste(psite,gap,sep='')
      if (!substr(psite,8,8) %in% c('S','T','Y')) {next}
      psite_vec <- c(psite_vec, psite)
      index_vec <- c(index_vec, i)
      
    } else {
      
      psite <- paste(sub_seq[(pos-7):(pos+7)],collapse='')
      if (!substr(psite,8,8) %in% c('S','T','Y')) {next}
      psite_vec <- c(psite_vec, psite)
      index_vec <- c(index_vec, i)
      
    }
  } 
}

# Remove potential hierarchical sites
bachmann_vec <- psite_vec
p1s <- rapply(strsplit(psite_vec,split=''), function(x) x[9]) == 'S'
p3s <- rapply(strsplit(psite_vec,split=''), function(x) x[11]) == 'S'
psite_no_heira <- psite_vec[!(p1s|p3s)]

# Bind flanking sequences to the original data frame

csnk2a_ksr <- csnk2a_ksr[index_vec,]
csnk2a_ksr <- csnk2a_ksr[!(p1s|p3s),]
csnk2a_ksr <- cbind(csnk2a_ksr, psite_no_heira)

# Construct the scoring function

source('match-tm.r')
csnk2_pwm <- makePWM(substr(psite_no_heira,2,14))

# Scoring function for the calculation of CK2 substrate quality

ED_weight <- function(psite,pwm) {
  
  neg_row <- apply(pwm[rownames(pwm) %in% c('D','E'),],2,sum)
  pwm <- pwm[!rownames(pwm) %in% c('D','E'),]
  pwm <- rbind(pwm,neg_row)
  rownames(pwm)[nrow(pwm)] <- 'DE'
  
  psite <- unlist(strsplit(psite,split=''))
  
  c=0
  min=0
  
  # Ignore the central residue
  for (i in c(1:6,8:13)) {
    
    aa <- psite[i]  
    if (aa %in% c('D','E')) {aa <- 'DE'}
    
    # Skip if the amino acid is not D or E
    if (!(aa %in% c('DE'))) {next}
    
    current <- pwm[rownames(pwm) %in% aa,i]
    c = c+current
  
  }
  
  maximum <- sum(pwm[rownames(pwm) == 'DE',][c(1:6,8:13)])
  mss = c/maximum
  
  return(unname(mss))
  
}

```

# The next step is to filter for CK2 target sites that fall in disordered regions. We will do this
# using an AlphaFold2-based assessment of protein disorder

```{r}

# AlphaFold disorder prediction on the basis of smoothened RSA (window size = 15)

AF2_accessibility <- readLines('9606.accessibility_windowed_scores.15.tdt')

AF2_vec <- NULL

count = 0

for (i in 1:nrow(csnk2a_ksr)) {
  
  print(i)
  
  accession <- csnk2a_ksr[i,3]
  pos <- csnk2a_ksr[i,4]
  
  grep_dex <- grep(accession,AF2_accessibility)
  
  # If we cannot find the corresponding residue in the accessibility file, then I will arbitrarily set
  # the disorder value to 0.5
  
  if (length(grep_dex) == 0) {disorder_pred <- 0.5; AF2_vec <- c(AF2_vec,disorder_pred); 
  count = count+1; next}
  
  disorder_pred <- AF2_accessibility[grep_dex]
  disorder_pred <- rapply(strsplit(disorder_pred,split='\t'), function(x) x[2])
  disorder_pred <- unlist(strsplit(disorder_pred,split=','))
  disorder_pred <- disorder_pred[pos]
  
  AF2_vec <- c(AF2_vec,disorder_pred)
  
}

AF2_vec <- as.numeric(AF2_vec)

# Now I will filter for phosphosites in disordered regions only
# For the cutoff, I will use the threshold that gives a 5% false discovery rate
# and 80% true positive rate

csnk2a_ksr_disorder <- csnk2a_ksr[which(AF2_vec >= 0.55),]
csnk2a_ksr_disorder <- cbind(csnk2a_ksr_disorder,AF2_vec[which(AF2_vec >= 0.55)])
colnames(csnk2a_ksr_disorder) <- c(colnames(csnk2a_ksr_disorder)[1:5],'sequence','AF2_disorder')

# Filter out redundant phosphosites assigned to the other catalytically active subunit

csnk2a_ksr_disorder_unique <- csnk2a_ksr_disorder[!duplicated(csnk2a_ksr_disorder[,6]),]

```

# Obtain list of all taxonomic divisions found in the data

```{r}

library(seqinr)

# Move to the directory containing all of the Ensembl orthologs where the spurious sequences have been removed by trimAl

setwd("vertebrate_ensembl_trimal_seq")

seq_files <- list.files()

# Fetch the names of the taxa (Ensembl annotation) for each orthologue

taxon_names_vec <- NULL

for (i in 1:length(seq_files)) {
  
  seq_file <- seqinr::read.fasta(seq_files[i],seqtype='AA')
  seq_file_names <- names(seq_file)
  taxon_names <- rapply(strsplit(seq_file_names,split='_'), function(x) x[length(x)])
  if(length(taxon_names) == 1) {next}
  taxon_names <- taxon_names[2:length(taxon_names)]
  taxon_names <- unique(taxon_names)
  taxon_names_vec <- c(taxon_names_vec, taxon_names)  
  
}

taxon_names_vec <- unique(taxon_names_vec)

# Manually arrange taxon names in chronological order

taxon_names_vec_ordered <- taxon_names_vec[c(9,10,11,3,18,20,19,21,1,14,4,15,5,7,16,17,8,6,13,2,12)]

# For each of the taxa we now need to (manually) give the divergence times obtained from TimeTree

taxon_names_vec_ordered_dates <- c(1105,824,684,615,473,435,413,352,312,177,159,105,96,90,74,67,43,29,20,16,9)
names(taxon_names_vec_ordered_dates) <- taxon_names_vec_ordered

# Place each age into one bin (>700mya, 200-700mya, <200mya)

### We group the vertebrates with the pre-vertebrates as -- since we use 1-to-1 orthologs and not 1-to-many --
### some sites in the 'Vertebrate' class may have an earlier origin

taxon_names_vec_ordered_bins <- c('old','old','old','old','intermediate','intermediate',
                                  'intermediate','intermediate','intermediate',
                                  'young','young','young','young','young','young','young',
                                  'young','young','young','young','young')

names(taxon_names_vec_ordered_bins) <- taxon_names_vec_ordered

```

### Iterate through each one of the phosphsosites, and then estimate the timepoint at which the S emerged

```{r}

library(seqinr)
library(ape)

# Directory of filtered alignment files
filtered_alignment_files <- list.files('vertebrate_ensembl_trimal_seq')

# Directory of unfiltered alignment files
alignment_files <- list.files('vertebrate_ensembl_aligned')

phospho_taxon_vec <- NULL

tally = 0

for (i in 1:nrow(csnk2a_ksr_disorder_unique))  {
  
  print(i)
  
  # There are a small number of orthologues
  # in primates that have identical sequences and therefore ASR does not work. We filter them out here.
  
  if (i %in% c(43,231,259,312)) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  phospho_taxon_oldest <- NULL
  
  accession <- csnk2a_ksr_disorder_unique[i,3]
  pos <- csnk2a_ksr_disorder_unique[i,4]
  
  # Retrieve the relevant sequence alignment
  
  filtered_alignment <- filtered_alignment_files[grep(accession,filtered_alignment_files)]
  
  # Skip if there were no filtered alignments for this accession
  
  if (length(filtered_alignment) == 0) {
    filtered_alignment <- alignment_files[grep(accession,alignment_files)]
    filtered_al_seq <- seqinr::read.fasta(paste('vertebrate_ensembl_aligned/',filtered_alignment,sep=''),seqtype='AA')
    
  } else {
  
    filtered_al_seq <- seqinr::read.fasta(paste('vertebrate_ensembl_trimal_seq/',filtered_alignment,sep=''),seqtype='AA')
    
  }
    
  # Skip if there is only one sequence
  
  if (length(filtered_al_seq) == 1) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  # First sequence is always human
  
  human_seq <- getSequence(filtered_al_seq[[1]])
  
  # Now map the human numbering to the alignment numbering
  
  count = 0
  al_pos_vec <- NULL
  human_pos_vec <- NULL
  
  for (j in 1:length(human_seq)) {
    
    aa <- human_seq[j]
    al_pos <- j
    
    if (aa != '-') {count=count+1; human_pos <- count}
    if (aa == '-') {count=count; human_pos <- '-'}
    
    al_pos_vec <- c(al_pos_vec, al_pos)
    human_pos_vec <- c(human_pos_vec, human_pos)
    
  }
  
  human_map_df <- data.frame(al_pos_vec, human_pos_vec,stringsAsFactors = FALSE)
  human_map_phospho_al <- human_map_df[human_map_df[,2] == pos,1]
  
  # Now read in the corresponding tree from FastML with ancestral sequence reconstructions
  
  filtered_al_tree_file <- paste('ASR_CK2/',accession,'/tree.newick.txt',sep='')
  filtered_al_tree <- ape::read.tree(filtered_al_tree_file)
  
  # N.B. Indices of the tips and nodes are given so that the tips is first, followed by the nodes
  tips <- filtered_al_tree$tip.label
  nodes <- filtered_al_tree$node.label
  
  # Obtain relevant tip/node indexes
  
  tip_dex <- which(tips==accession)
  root <- length(tips)+1
  
  # Path from root to accession tip
  
  accession_path <- nodepath(filtered_al_tree,from=root,to=tip_dex)
  
  # Remove the tip
  
  accession_path <- setdiff(accession_path,tip_dex)
  
  # Obtain the node indexes
  
  accession_path <- accession_path-length(tips)
  
  # Obtain internal path nodes
  
  path_nodes <- nodes[accession_path]
  
  # Path nodes from tip to root
  
  path_nodes <- rev(path_nodes)
 
  ############
  
  # Now, iterate through the nodes from tip to root to determine the first node that was not an S or T
  
  anc_seq_res_file <- paste('ASR_CK2/',accession,'/Ancestral_MaxMarginalProb_Char_Indel.txt',sep='')
  
  anc_seq_res <- read.table(anc_seq_res_file,head=T)
  anc_seq_res_pos <- anc_seq_res[anc_seq_res[,1] == human_map_phospho_al,]
  
  anc_aa_vec <- NULL
  
  for (j in 1:length(path_nodes)) {
    
    path_node <- path_nodes[j]
    
    anc_seq_res_pos_node <- anc_seq_res_pos[anc_seq_res_pos[,2] == path_node,]
    anc_seq_res_pos_node_aa <- anc_seq_res_pos_node[3]
    anc_seq_res_pos_node_aa <- as.character(unlist(unname(anc_seq_res_pos_node_aa)))
    
    anc_seq_res_pos_node_prob <- unlist(unname(anc_seq_res_pos_node[4]))
    
    # Consider the ancestral aa to be unknown if max probability < 0.5
    
    if (anc_seq_res_pos_node_prob < 0.5) {anc_seq_res_pos_node_aa <- '?'}
    names(anc_seq_res_pos_node_aa) <- path_node
    
    # Break the loop if the residue was not phosphorylatable
    if (!anc_seq_res_pos_node_aa %in% c('S','T')) {break}
    
    anc_aa_vec <- c(anc_aa_vec, anc_seq_res_pos_node_aa)
    
  } 
  
  # if the phosphosite is species-specific (skip the loop)
  if (length(anc_aa_vec) == 0) {phospho_taxon_vec <- c(phospho_taxon_vec, 'Human'); next}
  
  # Find the last node that is an S or T
  
  last_phospho <- anc_aa_vec[length(anc_aa_vec)]
  last_phospho_node <- names(last_phospho)
  last_phospho_node_index <- which(nodes == last_phospho_node)+length(tips)
  
  ## Now we need to find all tips arising from the node of interest
  
  global_path <- nodepath(filtered_al_tree,from=root)
  
  # Subset for paths that contain the node of interest
  phospho_paths <- global_path[grep(last_phospho_node_index,global_path)]
  
  # Retrieve the tip index for each path
  phospho_path_tips_index <- rapply(phospho_paths, function(x) x[length(x)])
  
  # Retrieve the tip for each path
  phospho_path_tips <- tips[phospho_path_tips_index]
  
  # Extract the taxa found across all relevant tips
  phospho_path_taxa <- rapply(strsplit(phospho_path_tips,split='_'), function(x) x[length(x)])
  
  # Retrieve the oldest taxon
  phospho_taxon_oldest <- taxon_names_vec_ordered[taxon_names_vec_ordered %in% phospho_path_taxa][1]
  
  phospho_taxon_vec <- c(phospho_taxon_vec, phospho_taxon_oldest)
  
}

phospho_taxon_vec_old <- phospho_taxon_vec

### Add taxon information to the data frame of CK2 substrates

csnk2a_disorder_sites_dates <- data.frame(csnk2a_ksr_disorder_unique,phospho_taxon_vec)

# Retrieve the estimated ages for each phosphosite

phospho_taxon_vec_dates <- taxon_names_vec_ordered_dates[match(phospho_taxon_vec,names(taxon_names_vec_ordered_dates))]

# Separate the dates into 3 bins ('old','intermediate', and 'young')

phospho_taxon_vec_bin <- taxon_names_vec_ordered_bins[match(phospho_taxon_vec,names(taxon_names_vec_ordered_bins))]

# Append this information to the data frame

csnk2a_disorder_sites_dates <- data.frame(csnk2a_ksr_disorder_unique,phospho_taxon_vec,phospho_taxon_vec_dates, phospho_taxon_vec_bin)

# Remove rows where date could not be estimated

csnk2a_disorder_sites_dates_NA_fil <- csnk2a_disorder_sites_dates[csnk2a_disorder_sites_dates[,8] != 'NA',]

```

### Now we essentially repeat the whole process described above but instead use high-confidence phosphosites found in human

```{r}

#########

# Load in the high-confidence psites

library(gdata)
library(readxl)
library(seqinr)
library(stringr)

ochoa <- read_xlsx('Ochoa_supplementary_3.xlsx', skip=0, col_names=TRUE, sheet=1)
name <- unlist(ochoa[,1])
pos <- unlist(ochoa[,2])

# Find high-confidence psites that map to CK2 targets

ochoa_name <- unname(name[name %in% csnk2a_disorder_sites_dates_NA_fil[,3]])
ochoa_pos <- unname(pos[name %in% csnk2a_disorder_sites_dates_NA_fil[,3]])
ochoa_df <- data.frame(ochoa_name,ochoa_pos)

# remove high-confidence human sites that overlap with known ck2 sites

ochoa_df <- ochoa_df[-which(paste(ochoa_name,ochoa_pos) %in% paste(csnk2a_ksr[,3],csnk2a_ksr[,4])),]

#### Date each one of the high-confidence phosphosites

library(seqinr)
library(ape)

filtered_alignment_files <- list.files('vertebrate_ensembl_trimal_seq')
alignment_files <- list.files('vertebrate_ensembl_aligned')

phospho_taxon_vec <- NULL

for (i in 1:nrow(ochoa_df))  { 
  
  print(i)
  
  # There are a small number of orthologues
  # in primates that have identical sequences and therefore ASR does not work. We filter them out here.
  
  phospho_taxon_oldest <- NULL
  
  accession <- ochoa_df[i,1]
  pos <- ochoa_df[i,2]
  
  # Retrieve the relevant sequence alignment
  
  filtered_alignment <- filtered_alignment_files[grep(accession,filtered_alignment_files)]
  
  # Skip if there were no filtered alignments for this accession
  
  if (length(filtered_alignment) == 0) {
    filtered_alignment <- alignment_files[grep(accession,alignment_files)]
    filtered_al_seq <- seqinr::read.fasta(paste('~/Documents/Work/CK2_MS/Figure_5/vertebrate_ensembl_aligned/',filtered_alignment,sep=''),seqtype='AA')
    
  } else {
  
    filtered_al_seq <- seqinr::read.fasta(paste('~/Documents/Work/CK2_MS/Figure_5/vertebrate_ensembl_trimal_seq/',filtered_alignment,sep=''),seqtype='AA')
    
  }
    
  # Skip if there is only one sequence
  
  if (length(filtered_al_seq) == 1) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  # Skip if all orthologs are identical
  
  if (length(which(duplicated(getSequence(filtered_al_seq)))) >= (length(filtered_al_seq)-3)) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  # First sequence is always human
  
  human_seq <- getSequence(filtered_al_seq[[1]])
  
  # Now map the human numbering to the alignment numbering
  
  count = 0
  al_pos_vec <- NULL
  human_pos_vec <- NULL
  
  for (j in 1:length(human_seq)) {
    
    aa <- human_seq[j]
    al_pos <- j
    
    if (aa != '-') {count=count+1; human_pos <- count}
    if (aa == '-') {count=count; human_pos <- '-'}
    
    al_pos_vec <- c(al_pos_vec, al_pos)
    human_pos_vec <- c(human_pos_vec, human_pos)
    
  }
  
  human_map_df <- data.frame(al_pos_vec, human_pos_vec,stringsAsFactors = FALSE)
  
  human_map_phospho_al <- human_map_df[human_map_df[,2] == pos,1]
  
  # Skip if the position is impossible (e.g. greater than the length of the protein)
  
  if (pos > length(filtered_al_seq[[1]][getSequence(filtered_al_seq[[1]]) != '-'])) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  # Now read in the tree from FastML
  
  filtered_al_tree_file <- paste('~/Documents/Work/CK2_MS/Figure_5/ASR_CK2/',accession,'/tree.newick.txt',sep='')
  filtered_al_tree <- ape::read.tree(filtered_al_tree_file)
  
  # N.B. Indices of the tips and nodes are given so that the tips is first, followed by the nodes
  tips <- filtered_al_tree$tip.label
  nodes <- filtered_al_tree$node.label
  
  # Obtain relevant tip/node indexes
  
  tip_dex <- which(tips==accession)
  root <- length(tips)+1
  
  # Path from root to accession tip
  
  accession_path <- nodepath(filtered_al_tree,from=root,to=tip_dex)
  
  # Remove the tip
  
  accession_path <- setdiff(accession_path,tip_dex)
  
  # Obtain the node indexes
  
  accession_path <- accession_path-length(tips)
  
  # Obtain internal path nodes
  
  path_nodes <- nodes[accession_path]
  
  # From tip to root
  
  path_nodes <- rev(path_nodes)
 
  ############
  
  # Now, we need to iterate through the nodes to determine the origin of the S or T
  
  anc_seq_res_file <- paste('ASR_CK2/',accession,'/Ancestral_MaxMarginalProb_Char_Indel.txt',sep='')
  
  anc_seq_res <- read.table(anc_seq_res_file,head=T)
  anc_seq_res_pos <- anc_seq_res[anc_seq_res[,1] == human_map_phospho_al,]
  
  anc_aa_vec <- NULL
  
  for (j in 1:length(path_nodes)) {
    
    path_node <- path_nodes[j]
    
    anc_seq_res_pos_node <- anc_seq_res_pos[anc_seq_res_pos[,2] == path_node,]
    anc_seq_res_pos_node_aa <- anc_seq_res_pos_node[3]
    anc_seq_res_pos_node_aa <- as.character(unlist(unname(anc_seq_res_pos_node_aa)))
    
    anc_seq_res_pos_node_prob <- unlist(unname(anc_seq_res_pos_node[4]))
    
    # Consider the ancestral aa to be unknown if max probability < 0.5
    
    if (anc_seq_res_pos_node_prob < 0.5) {anc_seq_res_pos_node_aa <- '?'}
    names(anc_seq_res_pos_node_aa) <- path_node
    if (!anc_seq_res_pos_node_aa %in% c('S','T')) {break}
    
    anc_aa_vec <- c(anc_aa_vec, anc_seq_res_pos_node_aa)
    
  } 
  
  # if the phosphosite is species-specific
  if (length(anc_aa_vec) == 0) {phospho_taxon_vec <- c(phospho_taxon_vec, 'Human'); next}
  
  # Last node that is an S or T
  
  last_phospho <- anc_aa_vec[length(anc_aa_vec)]
  last_phospho_node <- names(last_phospho)
  last_phospho_node_index <- which(nodes == last_phospho_node)+length(tips)
  
  # Now we need to find all tips arising from the node of interest
  
  global_path <- nodepath(filtered_al_tree,from=root)
  
  phospho_paths <- global_path[grep(last_phospho_node_index,global_path)]
  
  phospho_path_tips_index <- rapply(phospho_paths, function(x) x[length(x)])
  
  phospho_path_tips <- tips[phospho_path_tips_index]
  
  phospho_path_taxa <- rapply(strsplit(phospho_path_tips,split='_'), function(x) x[length(x)])
  
  phospho_taxon_oldest <- taxon_names_vec_ordered[taxon_names_vec_ordered %in% phospho_path_taxa][1]
  
  phospho_taxon_vec <- c(phospho_taxon_vec, phospho_taxon_oldest)
  
}

### append the taxon data to the data frame

ochoa_df_dates <- data.frame(ochoa_df,phospho_taxon_vec)

# Date each phospho site

phospho_taxon_vec_dates <- taxon_names_vec_ordered_dates[match(phospho_taxon_vec,names(taxon_names_vec_ordered_dates))]
phospho_taxon_vec_bin <- taxon_names_vec_ordered_bins[match(phospho_taxon_vec,names(taxon_names_vec_ordered_bins))]
ochoa_df_dates <- data.frame(ochoa_df,phospho_taxon_vec,phospho_taxon_vec_dates, phospho_taxon_vec_bin)
ochoa_df_dates_filtered <- ochoa_df_dates[ochoa_df_dates[,3] != 'NA',]
phospho_taxon_vec_Ochoa <- phospho_taxon_vec

```

# Repeat the procedure performed in the section directly above but instead for random S in disordered regions that are not known to be phosphorylated

```{r}

# AlphaFold2 data smoothened RSA data (window size = 15)
AF2_accessibility <- readLines('9606.accessibility_windowed_scores.15.tdt')

phospho_taxon_vec <- NULL

for (i in 1:nrow(csnk2a_ksr_disorder_unique))  {  
  
  print(i)
  
  # There are a small number of proteins with a small number of orthologues
  # in primates that have identical sequences and therefore ASR does not work. We filter them out here.
  
  if (i %in% c(43,231,259,312)) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  phospho_taxon_oldest <- NULL
  
  accession <- csnk2a_ksr_disorder_unique[i,3]
  
  # Collect position information for CK2 target sites and high-confidence phosphosites (we filter these out later)  
  ck2_pos <- csnk2a_ksr_disorder_unique[csnk2a_ksr_disorder_unique[,3]==accession,4]
  ochoa_pos <- ochoa_df[ochoa_df[,1] == accession,2]
  known_pos <- c(ck2_pos,ochoa_pos)
  
  # Retrieve the relevant sequence alignment
  
  filtered_alignment <- filtered_alignment_files[grep(accession,filtered_alignment_files)]
  
  # Skip if there were no filtered alignments for this accession
  
  if (length(filtered_alignment) == 0) {
    filtered_alignment <- alignment_files[grep(accession,alignment_files)]
    filtered_al_seq <- seqinr::read.fasta(paste('~/Documents/Work/CK2_MS/Figure_5/vertebrate_ensembl_aligned/',filtered_alignment,sep=''),seqtype='AA')
    
  } else {
  
    filtered_al_seq <- seqinr::read.fasta(paste('~/Documents/Work/CK2_MS/Figure_5/vertebrate_ensembl_trimal_seq/',filtered_alignment,sep=''),seqtype='AA')
    
  }
  
  # Skip if there is only one sequence
  
  if (length(filtered_al_seq) == 1) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  # First sequence is always human
  
  human_seq <- getSequence(filtered_al_seq[[1]])
  human_seq_raw <- human_seq[human_seq != '-']
  
  grep_dex <- grep(accession,AF2_accessibility)
  
  # Find positions of S residues
  human_seq_S <- which(human_seq_raw == 'S')
  
  # Filter out S that are known already to be phosphorylated
  human_seq_s_non_phos <- setdiff(human_seq_S,known_pos)
  
  # Skip is this protein does not have an AF2 model
  
  if (length(grep_dex) == 0)  {next}
  
  # Using AF2, we filter for S that are found in disordered regions only
  
  disorder_pred <- AF2_accessibility[grep_dex]
  disorder_pred <- rapply(strsplit(disorder_pred,split='\t'), function(x) x[2])
  disorder_pred <- unlist(strsplit(disorder_pred,split=','))
  
  if(length(human_seq_raw) != length(disorder_pred)) {stop('UniProt and AF2 length do not match')}
  
  human_seq_s_non_phos_AF2 <- as.numeric(disorder_pred[human_seq_s_non_phos])
  human_seq_non_phos_disorder <- human_seq_s_non_phos[which(human_seq_s_non_phos_AF2 >= 0.55)]
  
  # Skip if we cannot find any unphosphorylated S in disordered regions
  
  if(length(human_seq_non_phos_disorder) == 0) {next}
  
  # sample five disodrered S that are not phosphorylated
  
 if(length(human_seq_non_phos_disorder) >= 5) {
  
    pos_vec <- sample(human_seq_non_phos_disorder,5,replace=F)
  
 }  else {
   
    pos_vec <- sample(human_seq_non_phos_disorder,length(human_seq_non_phos_disorder),replace=F)
   
 }
  
  # Now map the human numbering to the alignment numbering
  
  count = 0
  al_pos_vec <- NULL
  human_pos_vec <- NULL
  
  for (j in 1:length(human_seq)) {
    
    aa <- human_seq[j]
    al_pos <- j
    
    if (aa != '-') {count=count+1; human_pos <- count}
    if (aa == '-') {count=count; human_pos <- '-'}
    
    al_pos_vec <- c(al_pos_vec, al_pos)
    human_pos_vec <- c(human_pos_vec, human_pos)
    
  }
  
  human_map_df <- data.frame(al_pos_vec, human_pos_vec,stringsAsFactors = FALSE)
  
  # Iterate through the five sampled S sites from tip to root and find the 'first' non-phosphorylatable node, using the exact same method as above
  
  for (z in 1:length(pos_vec)) {
    
    print(z)
    
    pos <- pos_vec[z]
    
    human_map_phospho_al <- human_map_df[human_map_df[,2] == pos,1]
    
    # Now read in the tree from FastML
    
    filtered_al_tree_file <- paste('~/Documents/Work/CK2_MS/Figure_5/ASR_CK2/',accession,'/tree.newick.txt',sep='')
    filtered_al_tree <- ape::read.tree(filtered_al_tree_file)
    
    # N.B. Indices of the tips and nodes are given so that the tips is first, followed by the nodes
    tips <- filtered_al_tree$tip.label
    nodes <- filtered_al_tree$node.label
    
    # Obtain relevant tip/node indexes
    
    tip_dex <- which(tips==accession)
    root <- length(tips)+1
    
    # Path from root to accession tip
    
    accession_path <- nodepath(filtered_al_tree,from=root,to=tip_dex)
    
    # Remove the tip
    
    accession_path <- setdiff(accession_path,tip_dex)
    
    # Obtain the node indexes
    
    accession_path <- accession_path-length(tips)
    
    # Obtain internal path nodes
    
    path_nodes <- nodes[accession_path]
    
    # From tip to root
    
    path_nodes <- rev(path_nodes)
   
    ############
    
    # Now, we need to iterate through the nodes to determine the origin of the S or T
    
    anc_seq_res_file <- paste('ASR_CK2/',accession,'/Ancestral_MaxMarginalProb_Char_Indel.txt',sep='')
    
    anc_seq_res <- read.table(anc_seq_res_file,head=T)
    anc_seq_res_pos <- anc_seq_res[anc_seq_res[,1] == human_map_phospho_al,]
    
    anc_aa_vec <- NULL
    
    for (j in 1:length(path_nodes)) {
      
      path_node <- path_nodes[j]
      
      anc_seq_res_pos_node <- anc_seq_res_pos[anc_seq_res_pos[,2] == path_node,]
      anc_seq_res_pos_node_aa <- anc_seq_res_pos_node[3]
      anc_seq_res_pos_node_aa <- as.character(unlist(unname(anc_seq_res_pos_node_aa)))
      
      anc_seq_res_pos_node_prob <- unlist(unname(anc_seq_res_pos_node[4]))
      
      # Consider the ancestral aa to be unknown if max probability < 0.5
      
      if (anc_seq_res_pos_node_prob < 0.5) {anc_seq_res_pos_node_aa <- '?'}
      names(anc_seq_res_pos_node_aa) <- path_node
      if (!anc_seq_res_pos_node_aa %in% c('S','T')) {break}
      
      anc_aa_vec <- c(anc_aa_vec, anc_seq_res_pos_node_aa)
      
    } 
    
    # if the phosphosite is species-specific
    if (length(anc_aa_vec) == 0) {phospho_taxon_vec <- c(phospho_taxon_vec, 'Human'); next}
    
    
    # Last node that is an S or T
    
    last_phospho <- anc_aa_vec[length(anc_aa_vec)]
    last_phospho_node <- names(last_phospho)
    last_phospho_node_index <- which(nodes == last_phospho_node)+length(tips)
    
    # Now we need to find all tips arising from the node of interest
    
    global_path <- nodepath(filtered_al_tree,from=root)
    
    phospho_paths <- global_path[grep(last_phospho_node_index,global_path)]
    
    phospho_path_tips_index <- rapply(phospho_paths, function(x) x[length(x)])
    
    phospho_path_tips <- tips[phospho_path_tips_index]
    
    phospho_path_taxa <- rapply(strsplit(phospho_path_tips,split='_'), function(x) x[length(x)])
    
    phospho_taxon_oldest <- taxon_names_vec_ordered[taxon_names_vec_ordered %in% phospho_path_taxa][1]
    
    phospho_taxon_vec <- c(phospho_taxon_vec, phospho_taxon_oldest)
  
  }  
    
}

phospho_taxon_vec_random <- phospho_taxon_vec

```

# Now we repeat the exact same procedure as above but this time looking for random A in disordered regions as a control

```{r}

# AlphaFold2 data smoothened RSA data (window size = 15)
AF2_accessibility <- readLines('9606.accessibility_windowed_scores.15.tdt')

phospho_taxon_vec <- NULL

for (i in 1:nrow(csnk2a_ksr_disorder_unique))  {  
  
  print(i)
  
  # We have a slight problem where there are a small number of proteins with a small number of orthologues
  # in primates that have identical sequences and therefore ASR does not work. We filter them out here.
  
  if (i %in% c(43,231,259,312)) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  phospho_taxon_oldest <- NULL
  
  accession <- csnk2a_ksr_disorder_unique[i,3]
  
  # Retrieve the relevant sequence alignment
  
  filtered_alignment <- filtered_alignment_files[grep(accession,filtered_alignment_files)]
  
  # Skip if there were no filtered alignments for this accession
  
  if (length(filtered_alignment) == 0) {
    filtered_alignment <- alignment_files[grep(accession,alignment_files)]
    filtered_al_seq <- seqinr::read.fasta(paste('vertebrate_ensembl_aligned/',filtered_alignment,sep=''),seqtype='AA')
    
  } else {
  
    filtered_al_seq <- seqinr::read.fasta(paste('vertebrate_ensembl_trimal_seq/',filtered_alignment,sep=''),seqtype='AA')
    
  }
  
  # Skip if there is only one sequence
  
  if (length(filtered_al_seq) == 1) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next}
  
  # First sequence is always human
  
  human_seq <- getSequence(filtered_al_seq[[1]])
  human_seq_raw <- human_seq[human_seq != '-']
  
  grep_dex <- grep(accession,AF2_accessibility)
  
  # Find the A residues
  human_seq_A <- which(human_seq_raw == 'A')
  human_seq_a_non_phos <- human_seq_A
  
  # Skip if the protein in question does not have an AF2 model
  if (length(grep_dex) == 0)  {next}
  
  # Use AF2 to find A residues that map to disordered regions only
  disorder_pred <- AF2_accessibility[grep_dex]
  disorder_pred <- rapply(strsplit(disorder_pred,split='\t'), function(x) x[2])
  disorder_pred <- unlist(strsplit(disorder_pred,split=','))
  
  if(length(human_seq_raw) != length(disorder_pred)) {stop('UniProt and AF2 length do not match')}
  
  human_seq_a_non_phos_AF2 <- as.numeric(disorder_pred[human_seq_a_non_phos])
  human_seq_non_phos_disorder <- human_seq_a_non_phos[which(human_seq_a_non_phos_AF2 >= 0.55)]
  
  # sample five disorered A residues
  
  if(length(human_seq_non_phos_disorder) == 0) {next}
  
 if(length(human_seq_non_phos_disorder) >= 5) {
  
    pos_vec <- sample(human_seq_non_phos_disorder,5,replace=F)
  
 }  else {
   
    pos_vec <- sample(human_seq_non_phos_disorder,length(human_seq_non_phos_disorder),replace=F)
   
 }
  
  # Now map the human numbering to the alignment numbering
  
  count = 0
  al_pos_vec <- NULL
  human_pos_vec <- NULL
  
  for (j in 1:length(human_seq)) {
    
    aa <- human_seq[j]
    al_pos <- j
    
    if (aa != '-') {count=count+1; human_pos <- count}
    if (aa == '-') {count=count; human_pos <- '-'}
    
    al_pos_vec <- c(al_pos_vec, al_pos)
    human_pos_vec <- c(human_pos_vec, human_pos)
    
  }
  
  human_map_df <- data.frame(al_pos_vec, human_pos_vec,stringsAsFactors = FALSE)
  
  for (z in 1:length(pos_vec)) {
    
    print(z)
    
    pos <- pos_vec[z]
    
    human_map_phospho_al <- human_map_df[human_map_df[,2] == pos,1]
    
    # Now read in the tree from FastML
    
    filtered_al_tree_file <- paste('ASR_CK2/',accession,'/tree.newick.txt',sep='')
    filtered_al_tree <- ape::read.tree(filtered_al_tree_file)
    
    # N.B. Indices of the tips and nodes are given so that the tips is first, followed by the nodes
    tips <- filtered_al_tree$tip.label
    nodes <- filtered_al_tree$node.label
    
    # Obtain relevant tip/node indexes
    
    tip_dex <- which(tips==accession)
    root <- length(tips)+1
    
    # Path from root to accession tip
    
    accession_path <- nodepath(filtered_al_tree,from=root,to=tip_dex)
    
    # Remove the tip
    
    accession_path <- setdiff(accession_path,tip_dex)
    
    # Obtain the node indexes
    
    accession_path <- accession_path-length(tips)
    
    # Obtain internal path nodes
    
    path_nodes <- nodes[accession_path]
    
    # From tip to root
    
    path_nodes <- rev(path_nodes)
   
    ############
    
    # Using the same approach as before, going from tip to root, find the first node that is not an 'A'
    
    anc_seq_res_file <- paste('~/Documents/Work/CK2_MS/Figure_5/ASR_CK2/',accession,'/Ancestral_MaxMarginalProb_Char_Indel.txt',sep='')
    
    anc_seq_res <- read.table(anc_seq_res_file,head=T)
    anc_seq_res_pos <- anc_seq_res[anc_seq_res[,1] == human_map_phospho_al,]
    
    anc_aa_vec <- NULL
    
    for (j in 1:length(path_nodes)) {
      
      path_node <- path_nodes[j]
      
      anc_seq_res_pos_node <- anc_seq_res_pos[anc_seq_res_pos[,2] == path_node,]
      anc_seq_res_pos_node_aa <- anc_seq_res_pos_node[3]
      anc_seq_res_pos_node_aa <- as.character(unlist(unname(anc_seq_res_pos_node_aa)))
      
      anc_seq_res_pos_node_prob <- unlist(unname(anc_seq_res_pos_node[4]))
      
      # Consider the ancestral aa to be unknown if max probability < 0.5
      
      if (anc_seq_res_pos_node_prob < 0.5) {anc_seq_res_pos_node_aa <- '?'}
      names(anc_seq_res_pos_node_aa) <- path_node
      if (!anc_seq_res_pos_node_aa %in% c('A')) {break}
      
      anc_aa_vec <- c(anc_aa_vec, anc_seq_res_pos_node_aa)
      
    } 
    
    # if the phosphosite is species-specific
    if (length(anc_aa_vec) == 0) {phospho_taxon_vec <- c(phospho_taxon_vec, 'Human'); next}
    
    
    # Last node that is an A
    
    last_phospho <- anc_aa_vec[length(anc_aa_vec)]
    last_phospho_node <- names(last_phospho)
    last_phospho_node_index <- which(nodes == last_phospho_node)+length(tips)
    
    # Now we need to find all tips arising from the node of interest
    
    global_path <- nodepath(filtered_al_tree,from=root)
    
    phospho_paths <- global_path[grep(last_phospho_node_index,global_path)]
    
    phospho_path_tips_index <- rapply(phospho_paths, function(x) x[length(x)])
    
    phospho_path_tips <- tips[phospho_path_tips_index]
    
    phospho_path_taxa <- rapply(strsplit(phospho_path_tips,split='_'), function(x) x[length(x)])
    
    phospho_taxon_oldest <- taxon_names_vec_ordered[taxon_names_vec_ordered %in% phospho_path_taxa][1]
    
    phospho_taxon_vec <- c(phospho_taxon_vec, phospho_taxon_oldest)
  
  }  
    
}

phospho_taxon_vec_A <- phospho_taxon_vec

```

# Stacked barplot for CK2, high-confidence phospho, and random S, and random A

```{r}

phospho_taxon_vec_bin_A <- taxon_names_vec_ordered_bins[match(phospho_taxon_vec_A,names(taxon_names_vec_ordered_bins))]
phospho_taxon_vec_bin_A <- phospho_taxon_vec_bin_A[!is.na(phospho_taxon_vec_bin_A)]

phospho_taxon_vec_bin_S <- taxon_names_vec_ordered_bins[match(phospho_taxon_vec_random,names(taxon_names_vec_ordered_bins))]
phospho_taxon_vec_bin_S <- phospho_taxon_vec_bin_S[!is.na(phospho_taxon_vec_bin_S)]

phospho_taxon_vec_bin_ochoa <- taxon_names_vec_ordered_bins[match(phospho_taxon_vec_Ochoa,names(taxon_names_vec_ordered_bins))]
phospho_taxon_vec_bin_ochoa <- phospho_taxon_vec_bin_ochoa[!is.na(phospho_taxon_vec_bin_ochoa)]

phospho_taxon_vec_bin_CK2 <- taxon_names_vec_ordered_bins[match(phospho_taxon_vec_old,names(taxon_names_vec_ordered_bins))]
phospho_taxon_vec_bin_CK2 <- phospho_taxon_vec_bin_CK2[!is.na(phospho_taxon_vec_bin_CK2)]

####

A_df <- data.frame(rep('A',3),names(table(phospho_taxon_vec_bin_A)),unname(table(phospho_taxon_vec_bin_A)))
A_df <- A_df[,-3]
colnames(A_df) <- c('class','age','freq')

random_df <- data.frame(rep('S (non-phospho)',3),names(table(phospho_taxon_vec_bin_S)),unname(table(phospho_taxon_vec_bin_S)))
random_df <- random_df[,-3]
colnames(random_df) <- c('class','age','freq')

ochoa_df <- data.frame(rep('S/T (phospho)',3),names(table(phospho_taxon_vec_bin_ochoa)),unname(table(phospho_taxon_vec_bin_ochoa)))
ochoa_df <- ochoa_df[,-3]
colnames(ochoa_df) <- c('class','age','freq')

ck2_df <- data.frame(rep('S/T (CK2)',3),names(table(phospho_taxon_vec_bin_CK2)),unname(table(phospho_taxon_vec_bin_CK2)))
ck2_df <- ck2_df[,-3]
colnames(ck2_df) <- c('class','age','freq')

summary_df <- rbind(A_df, random_df, ochoa_df, ck2_df)

summary_df$age <- factor(summary_df$age, levels = c('young','intermediate','old'))
summary_df$class <- factor(summary_df$class, levels = c('A','S/T (phospho)','S (non-phospho)','S/T (CK2)'))

bin_count <- c(sum(summary_df[1:3,3]),sum(summary_df[4:6,3]),sum(summary_df[7:9,3]),sum(summary_df[10:12,3]))
bin_text <- c(rep('',2),bin_count[1],rep('',2),bin_count[2],rep('',2),bin_count[3],rep('',2),bin_count[4])

##### Generate the stacked barplot

p <- ggplot(summary_df, aes(fill=age, y=freq, x=class)) + 
    geom_bar(position="fill", stat="identity",color='black',size=1)

p <- p+scale_fill_manual(values=c(colors()[109], colors()[121], colors()[132]))

# Font
p <- p+theme_bw() + theme(text=element_text(family="Ubuntu Light", face="plain", size=15),panel.border = element_rect(color="black", size=1.2, linetype="solid"))

# Ticks
p <- p+theme(axis.ticks.length=unit(-0.10, "cm"), axis.text.x = element_text(margin=unit(c(0.2,0.2,0.2,0.2), "cm")), axis.text.y = element_text(margin=unit(c(0.2,0.2,0.2,0.2), "cm")) )

p <- p + ylab("Relative frequency") + xlab("") + ggtitle('')
p <- p+theme(axis.text=element_text(size=7),axis.title.x=element_text(size=11,face="bold"),axis.title.y=element_text(size=11,face="bold"),plot.title=element_text(size=18,face='bold'))

#p <- p + theme(legend.position = "none") # axis.line = element_blank(), panel.border = element_blank())

p <- p + theme(legend.title = element_text(size=9.5), legend.text = element_text(size=8))

p <- p+geom_text(data=summary_df, aes(x=class),y=rep(1.025,12),label=bin_text,col='black', fontface='plain', size=3.6)

ggsave(file='Supplementary_figure_12a.pdf', plot=p, width=5.15, height=4.8)

```



