---
title: "Supplementary figure 12e"
author: "David Bradley"
date: "1/1/2021"
output: html_document
---

### Now we need to run through each one of the results files and try to date the last ancestor with an S

# GGplot font

```{r}

# https://stackoverflow.com/questions/27689222/changing-fonts-for-graphs-in-r

library(extrafont)

font_import()
loadfonts()       #Register fonts for Windows bitmap output
fonts() 

```

# The first step is to model the specificity of CK2

```{r}

library(stringr)
library(readr)
library(seqinr)
library(ggseqlogo)
library(gdata)

# Data comes from Bachmann et al., 2019 (https://www.biorxiv.org/content/10.1101/822668v3)

prot_mapper <- read_csv('export.csv')

# Kinases only

prot_mapper <- prot_mapper[unlist(prot_mapper[,5]) == TRUE,]

# Retrieve upstream kinase, substrate, and substrate position

ksr <- prot_mapper[,c(3,4,6,9,10)]

# We exclude KSRs that are supported only by the text-mining tools

curated <- c('psp','signor','pid','bel','reactome')

source_list <- strsplit(unlist(ksr[,5]),split=',')

number_curated <- lapply(source_list, function(x) length(intersect(x,curated)))

ksr <- ksr[which(number_curated > 0),]

# Correct formatting problems

for (i in 1:nrow(ksr)) {
 
  if(is.na(ksr[i,2])) {ksr[i,2] <- ksr[i,1]} 
  
}

# Retrieve CSNK2A1 and CSNK2A2 substrates

csnk2a1_ksr <- ksr[which(unlist(ksr[,2] == 'CSNK2A1') == TRUE),]
csnk2a2_ksr <- ksr[which(unlist(ksr[,2] == 'CSNK2A2') == TRUE),]
csnk2a_ksr <- unique(rbind(csnk2a1_ksr,csnk2a2_ksr)) 

hs_rp <- read.fasta('hs_proteome_uniprot.fasta', seqtype='AA')
hs_ids <- rapply(strsplit(names(hs_rp),split='\\|'),function(x) x[2])

# Retrieve the sequences

psite_vec <- NULL
index_vec <- NULL

for (i in 1:nrow(csnk2a_ksr)) {
  
  print(i)
  
  # Retrieve the first element only
  uniprot_id <- unname(unlist(csnk2a_ksr[i,3]))
  site_pos <- unname(unlist(csnk2a_ksr[i,4]))
  
  # Loop for ambiguous psite positions
  
  for (j in 1:length(uniprot_id)) {
    
    pos <- as.numeric(site_pos)
    
    # Substrate sequence
  
    sub_seq <- unlist(getSequence(hs_rp[hs_ids %in% uniprot_id[j]]))
    
    if (length(sub_seq) == 0) {next}
    
    # Phosphosite position
    
    if (pos < 8) {
      
      gap <- paste(rep('_',(8-pos)),collapse='')
      psite <- paste(sub_seq[1:(pos+7)],collapse='')
      psite <- paste(gap,psite,sep='')
      if (!substr(psite,8,8) %in% c('S','T','Y')) {next}
      psite_vec <- c(psite_vec, psite)
      index_vec <- c(index_vec, i)
      
    } else if ((pos+7) > length(sub_seq)) {
      
      psite <- paste(sub_seq[(pos-7):(length(sub_seq))],collapse='')
      gap <- paste(rep('_',(pos+7)-length(sub_seq)),collapse='')
      psite <- paste(psite,gap,sep='')
      if (!substr(psite,8,8) %in% c('S','T','Y')) {next}
      psite_vec <- c(psite_vec, psite)
      index_vec <- c(index_vec, i)
      
    } else {
      
      psite <- paste(sub_seq[(pos-7):(pos+7)],collapse='')
      if (!substr(psite,8,8) %in% c('S','T','Y')) {next}
      psite_vec <- c(psite_vec, psite)
      index_vec <- c(index_vec, i)
      
    }
  } 
}

# After removing potential heirarchical sites

bachmann_vec <- psite_vec
p1s <- rapply(strsplit(psite_vec,split=''), function(x) x[9]) == 'S'
p3s <- rapply(strsplit(psite_vec,split=''), function(x) x[11]) == 'S'
psite_no_heira <- psite_vec[!(p1s|p3s)]

# Bind it to the original data frame

csnk2a_ksr <- csnk2a_ksr[index_vec,]
csnk2a_ksr <- csnk2a_ksr[!(p1s|p3s),]
csnk2a_ksr <- cbind(csnk2a_ksr, psite_no_heira)

# Construct the scoring function

source('match-tm.r')
csnk2_pwm <- makePWM(substr(psite_no_heira,2,14))

# Negative charge scoring function

ED_weight <- function(psite,pwm) {
  
  neg_row <- apply(pwm[rownames(pwm) %in% c('D','E'),],2,sum)
  pwm <- pwm[!rownames(pwm) %in% c('D','E'),]
  pwm <- rbind(pwm,neg_row)
  rownames(pwm)[nrow(pwm)] <- 'DE'
  
  psite <- unlist(strsplit(psite,split=''))
  
  c=0
  min=0
  
  # Ignore the central residue
  for (i in c(1:6,8:13)) {
    
    aa <- psite[i]  
    if (aa %in% c('D','E')) {aa <- 'DE'}
    
    # Skip if the amino acid is not D or E
    if (!(aa %in% c('DE'))) {next}
    
    current <- pwm[rownames(pwm) %in% aa,i]
    c = c+current
  
  }
  
  maximum <- sum(pwm[rownames(pwm) == 'DE',][c(1:6,8:13)])
  mss = c/maximum
  
  return(unname(mss))
  
}

```

# The next step is to filter for CK2 target sites that fall in disordered regions. We will do this
# using an AlphaFold2-based assessment of protein disorder

```{r}

# AlphaFold disorder prediction on the basis of accessibility

AF2_accessibility <- readLines('9606.accessibility_windowed_scores.15.tdt')

AF2_vec <- NULL

count = 0

for (i in 1:nrow(csnk2a_ksr)) {
  
  print(i)
  
  accession <- csnk2a_ksr[i,3]
  pos <- csnk2a_ksr[i,4]
  
  grep_dex <- grep(accession,AF2_accessibility)
  
  # If we cannot find the corresponding residue in the accessibility file, then I will arbitrarily set
  # the disorder value to 0.5
  
  if (length(grep_dex) == 0) {disorder_pred <- 0.5; AF2_vec <- c(AF2_vec,disorder_pred); 
  count = count+1; next}
  
  disorder_pred <- AF2_accessibility[grep_dex]
  disorder_pred <- rapply(strsplit(disorder_pred,split='\t'), function(x) x[2])
  disorder_pred <- unlist(strsplit(disorder_pred,split=','))
  disorder_pred <- disorder_pred[pos]
  
  AF2_vec <- c(AF2_vec,disorder_pred)
  
}

AF2_vec <- as.numeric(AF2_vec)

# Now I will filter for phosphosites in disordered regions only
# For the cutoff, I will use the threshold that gives a 5% false discovery rate
# and 80% true positive rate

csnk2a_ksr_disorder <- csnk2a_ksr[which(AF2_vec >= 0.55),]
csnk2a_ksr_disorder <- cbind(csnk2a_ksr_disorder,AF2_vec[which(AF2_vec >= 0.55)])
colnames(csnk2a_ksr_disorder) <- c(colnames(csnk2a_ksr_disorder)[1:5],'sequence','AF2_disorder')

# Filter out redundant phosphosites assigned to the other enzyme subunit

csnk2a_ksr_disorder_unique <- csnk2a_ksr_disorder[!duplicated(csnk2a_ksr_disorder[,6]),]

```

# Obtain list of all taxonomic divisions found in my data

```{r}

library(seqinr)

setwd("vertebrate_ensembl_trimal_seq")

seq_files <- list.files()

taxon_names_vec <- NULL

for (i in 1:length(seq_files)) {
  
  seq_file <- seqinr::read.fasta(seq_files[i],seqtype='AA')
  seq_file_names <- names(seq_file)
  taxon_names <- rapply(strsplit(seq_file_names,split='_'), function(x) x[length(x)])
  if(length(taxon_names) == 1) {next}
  taxon_names <- taxon_names[2:length(taxon_names)]
  taxon_names <- unique(taxon_names)
  taxon_names_vec <- c(taxon_names_vec, taxon_names)  
  
}

taxon_names_vec <- unique(taxon_names_vec)

# Manually arrange taxon names in chronological order

taxon_names_vec_ordered <- taxon_names_vec[c(9,10,11,3,18,20,19,21,1,14,4,15,5,7,16,17,8,6,13,2,12)]

# For each of the taxa we now need to give the divergence times obtained from TimeTree

taxon_names_vec_ordered_dates <- c(1105,824,684,615,473,435,413,352,312,177,159,105,96,90,74,67,43,29,20,16,9)
names(taxon_names_vec_ordered_dates) <- taxon_names_vec_ordered

# Place each age into one bin (>700mya, 200-700mya, <200mya)

taxon_names_vec_ordered_bins <- c('old','old','old','old','intermediate','intermediate',
                                  'intermediate','intermediate','intermediate',
                                  'young','young','young','young','young','young','young',
                                  'young','young','young','young','young')

names(taxon_names_vec_ordered_bins) <- taxon_names_vec_ordered

```

### Now we need to iterate through each one of the phosphsosites and then out put the subtree with an ancestral S and all
### descendant sequences

```{r}

library(seqinr)
library(ape)

filtered_alignment_files <- list.files('vertebrate_ensembl_trimal_seq')
alignment_files <- list.files('vertebrate_ensembl_aligned')

tree_files <- list.files('vertebrate_ensembl_FastTree_rooted')

phospho_taxon_vec <- NULL
root_seq_vec <- NULL

# modify code slightly to extract the phosphosite flanking sequence at the root

for (i in 1:nrow(csnk2a_ksr_disorder_unique))  {  #(i in c(1:42,44:230,232:258,260:311,313:nrow(csnk2a_ksr_disorder_unique)))
  
  print(i)
  
  # There are a small number of proteins with a small number of orthologues
  # in primates that have identical sequences and therefore ASR does not work. We filter them out here.
  
  if (i %in% c(43,231,259,312)) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); root_seq_vec <- c(root_seq_vec, 'NA'); next}
  
  phospho_taxon_oldest <- NULL
  
  accession <- csnk2a_ksr_disorder_unique[i,3]
  pos <- csnk2a_ksr_disorder_unique[i,4]
  
  # Retrieve the relevant sequence alignment
  
  filtered_alignment <- filtered_alignment_files[grep(accession,filtered_alignment_files)]
  
  # Skip if there were no filtered alignments for this accession
  
  if (length(filtered_alignment) == 0) {
    filtered_alignment <- alignment_files[grep(accession,alignment_files)]
    filtered_al_seq <- seqinr::read.fasta(paste('vertebrate_ensembl_aligned/',filtered_alignment,sep=''),seqtype='AA')
    
    #phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); next
    
  } else {
  
    filtered_al_seq <- seqinr::read.fasta(paste('vertebrate_ensembl_trimal_seq/',filtered_alignment,sep=''),seqtype='AA')
    
  }
    
  # Skip if there is only one sequence
  
  if (length(filtered_al_seq) == 1) {phospho_taxon_vec <- c(phospho_taxon_vec, 'NA'); root_seq_vec <- c(root_seq_vec, 'NA'); next}
  
  # First sequence is always human
  
  human_seq <- getSequence(filtered_al_seq[[1]])
  
  # Now map the human numbering to the alignment numbering
  
  count = 0
  al_pos_vec <- NULL
  human_pos_vec <- NULL
  
  for (j in 1:length(human_seq)) {
    
    aa <- human_seq[j]
    al_pos <- j
    
    if (aa != '-') {count=count+1; human_pos <- count}
    if (aa == '-') {count=count; human_pos <- '-'}
    
    al_pos_vec <- c(al_pos_vec, al_pos)
    human_pos_vec <- c(human_pos_vec, human_pos)
    
  }
  
  human_map_df <- data.frame(al_pos_vec, human_pos_vec,stringsAsFactors = FALSE)
  
  human_map_phospho_al <- human_map_df[human_map_df[,2] == pos,1]
  
  # Extract the flanking sequence positions (works just as well for psites at start or end of sequence)
  
  human_map_phospho_flank_al <- human_map_df[match((pos-6):(pos+6),human_map_df[,2]),1]
  
  # Now read in the tree from FastML
  
  filtered_al_tree_file <- paste('ASR_CK2/',accession,'/tree.newick.txt',sep='')
  filtered_al_tree <- ape::read.tree(filtered_al_tree_file)
  
  fast_tree_file <- paste('vertebrate_ensembl_FastTree_rooted/',tree_files[grep(accession,tree_files)],sep='')
  fast_tree <- ape::read.tree(fast_tree_file)
  
  # N.B. Indices of the tips and nodes are given so that the tips is first, followed by the nodes
  tips <- filtered_al_tree$tip.label
  nodes <- filtered_al_tree$node.label
  
  # Obtain relevant tip/node indexes
  
  tip_dex <- which(tips==accession)
  root <- length(tips)+1
  
  # Path from root to accession tip
  
  accession_path <- nodepath(filtered_al_tree,from=root,to=tip_dex)
  
  # Remove the tip
  
  accession_path <- setdiff(accession_path,tip_dex)
  
  # Obtain the node indexes
  
  accession_path <- accession_path-length(tips)
  
  # Obtain internal path nodes
  
  path_nodes <- nodes[accession_path]
  
  # From tip to root
  
  path_nodes <- rev(path_nodes)
 
  ############
  
  # Now, we need to iterate through the nodes to determine the origin of the S or T
  
  anc_seq_res_file <- paste('ASR_CK2/',accession,'/Ancestral_MaxMarginalProb_Char_Indel.txt',sep='')
  
  anc_seq_res <- read.table(anc_seq_res_file,head=T)
  anc_seq_res_pos <- anc_seq_res[anc_seq_res[,1] == human_map_phospho_al,]
  
  anc_aa_vec <- NULL
  
  for (j in 1:length(path_nodes)) {
    
    path_node <- path_nodes[j]
    
    anc_seq_res_pos_node <- anc_seq_res_pos[anc_seq_res_pos[,2] == path_node,]
    anc_seq_res_pos_node_aa <- anc_seq_res_pos_node[3]
    anc_seq_res_pos_node_aa <- as.character(unlist(unname(anc_seq_res_pos_node_aa)))
    
    anc_seq_res_pos_node_prob <- unlist(unname(anc_seq_res_pos_node[4]))
    
    # Consider the ancestral aa to be unknown if max probability < 0.5
    
    if (anc_seq_res_pos_node_prob < 0.5) {anc_seq_res_pos_node_aa <- '?'}
    names(anc_seq_res_pos_node_aa) <- path_node
    if (!anc_seq_res_pos_node_aa %in% c('S','T')) {break}
    
    anc_aa_vec <- c(anc_aa_vec, anc_seq_res_pos_node_aa)
    
  } 
  
  # if the phosphosite is species-specific
  if (length(anc_aa_vec) == 0) {phospho_taxon_vec <- c(phospho_taxon_vec, 'Human'); root_seq_vec <- c(root_seq_vec, 'Human'); next}
  
  # Last node that is an S or T
  
  last_phospho <- anc_aa_vec[length(anc_aa_vec)]
  last_phospho_node <- names(last_phospho)
  last_phospho_node_index <- which(nodes == last_phospho_node)+length(tips)
  
  # extract the root resquence ((works just as well for psites at start or end of sequence)
  
  pos_n_6 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[1],3]
  pos_n_5 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[2],3]
  pos_n_4 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[3],3]
  pos_n_3 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[4],3]
  pos_n_2 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[5],3]
  pos_n_1 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[6],3]
  pos_0 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[7],3]
  pos_p_1 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[8],3]
  pos_p_2 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[9],3]
  pos_p_3 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[10],3]
  pos_p_4 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[11],3]
  pos_p_5 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[12],3]
  pos_p_6 <- anc_seq_res[anc_seq_res[,2] == last_phospho_node & anc_seq_res[,1] == human_map_phospho_flank_al[13],3]
  
  # Account for psites at start or end of the protein sequence
  
  if(is.na(pos_n_6[1])) {pos_n_6 <- '_'}
  if(is.na(pos_n_5[1])) {pos_n_5 <- '_'}
  if(is.na(pos_n_4[1])) {pos_n_4 <- '_'}
  if(is.na(pos_n_3[1])) {pos_n_3 <- '_'}
  if(is.na(pos_n_2[1])) {pos_n_2 <- '_'}
  if(is.na(pos_n_1[1])) {pos_n_1 <- '_'}
  
  if(is.na(pos_0[1])) {pos_0 <- '_'}
  
  if(is.na(pos_p_1[1])) {pos_p_1 <- '_'}
  if(is.na(pos_p_2[1])) {pos_p_2 <- '_'}
  if(is.na(pos_p_3[1])) {pos_p_3 <- '_'}
  if(is.na(pos_p_4[1])) {pos_p_4 <- '_'}
  if(is.na(pos_p_5[1])) {pos_p_5 <- '_'}
  if(is.na(pos_p_6[1])) {pos_p_6 <- '_'}
  
  phosphosite_root_seq <- paste(pos_n_6,pos_n_5,pos_n_4,pos_n_3,pos_n_2,pos_n_1,pos_0,pos_p_1,pos_p_2,pos_p_3,pos_p_4,pos_p_5,pos_p_6,sep='')
  
  root_seq_vec <- c(root_seq_vec, phosphosite_root_seq)
  
  # Now we need to find all tips arising from the node of interest
  
  global_path <- nodepath(filtered_al_tree,from=root)
  
  phospho_paths <- global_path[grep(last_phospho_node_index,global_path)]
  
  phospho_path_tips_index <- rapply(phospho_paths, function(x) x[length(x)])
  
  phospho_path_tips <- tips[phospho_path_tips_index]
  
  phospho_path_taxa <- rapply(strsplit(phospho_path_tips,split='_'), function(x) x[length(x)])
  
  phospho_taxon_oldest <- taxon_names_vec_ordered[taxon_names_vec_ordered %in% phospho_path_taxa][1]
  
  phospho_taxon_vec <- c(phospho_taxon_vec, phospho_taxon_oldest)
  
  ## Now, we need to write out the sub-tree with an S/T ancestor and all descendant nodes
  
  sub_tree <- keep.tip(fast_tree, phospho_path_tips)
  sub_tree_file <- paste('vertebrate_ensembl_FastTree_anc_ST/',accession,'_',pos,'_subtree.tre',sep='')
  #write.tree(sub_tree, file=sub_tree_file)
  
  sub_filtered_al_seq <- filtered_al_seq[names(filtered_al_seq) %in% phospho_path_tips]
  sub_seq_file <- paste('vertebrate_ensembl_seq_anc_ST/',accession,'_',pos,'_subseq.fa',sep='')
  #write.fasta(sub_filtered_al_seq, names=names(sub_filtered_al_seq), file.out=sub_seq_file)
  
}

### Construct the dataframe

csnk2a_disorder_root_seq <- data.frame(csnk2a_ksr_disorder_unique,root_seq_vec)
csnk2a_disorder_root_seq[,6] <- substr(csnk2a_disorder_root_seq[,6],2,14)

# Filter out NA sites

csnk2a_disorder_root_seq_filter <- csnk2a_disorder_root_seq[csnk2a_disorder_root_seq[,8] != 'NA',]

# Pyvolve cannot model indels and so we will filter out any sites that have '-' in them

csnk2a_disorder_root_seq_filter_gap_filter <- csnk2a_disorder_root_seq_filter[-grep('-',csnk2a_disorder_root_seq_filter[,8]),]
csnk2a_disorder_root_seq_filter_gap_filter <- csnk2a_disorder_root_seq_filter_gap_filter[csnk2a_disorder_root_seq_filter_gap_filter[,8] != 'Human',]
pyvolve_DF <- csnk2a_disorder_root_seq_filter_gap_filter

```

# For each entry, find the oldest taxon amongst the species

```{r}

setwd("Pyvolve_real")

date_vec <- NULL
oldest_taxon_vec <- NULL

for (i in 1:nrow(pyvolve_DF)) {
  
  setwd("Pyvolve_real")
  
  print(i)
  
  accession <- pyvolve_DF[i,3]
  pos <- pyvolve_DF[i,4]
  root_seq <- as.character(pyvolve_DF[i,8])
  site_tag <- paste(accession,'_',pos,sep='')
  
   # Move into the correct directory                  
                    
  new_direc <- paste(getwd(),'/',site_tag,'_pyvolve_results',sep='')
  setwd(new_direc)
  
  new_direc_files <- list.files()
  
  fasta_file <- new_direc_files[1]
    
  # Read in the fasta file and find the oldest taxon
  
  seq <- read.fasta(fasta_file, seqtype='AA')  
  seq_names <- names(seq)
  seq_taxon <- rapply(strsplit(seq_names,split='_'), function(x) x[length(x)])
  oldest_taxon <- taxon_names_vec_ordered[taxon_names_vec_ordered %in% seq_taxon][1]
  date <- unname(taxon_names_vec_ordered_dates[match(oldest_taxon,names(taxon_names_vec_ordered_dates))])
  
  oldest_taxon_vec <- c(oldest_taxon_vec, oldest_taxon)
  date_vec <- c(date_vec, date)
  
}

pyvolve_DF <- data.frame(pyvolve_DF, oldest_taxon_vec, date_vec)
colnames(pyvolve_DF)[c(8,9,10)] <- c('root_seq','oldest_taxon','age')

```

# Score each one of the phosphosites (root seq)

```{r}

sq_vec <- NULL

for (i in 1:nrow(pyvolve_DF)) {
  
  psite <- as.character(pyvolve_DF[i,8])
  sq <- ED_weight(psite,csnk2_pwm)
  sq_vec <- c(sq_vec,sq)
  
}

pyvolve_DF <- data.frame(pyvolve_DF,sq_vec)

# Filter out human sites that are hierarchical or have a central T

pyvolve_DF <- pyvolve_DF[filter_dex,]

```

# Score each one of the phosphosites (human seq)

```{r}

sq_hs_vec <- NULL

for (i in 1:nrow(pyvolve_DF)) {
  
  psite <- as.character(pyvolve_DF[i,6])
  sq <- ED_weight(psite,csnk2_pwm)
  sq_hs_vec <- c(sq_hs_vec,sq)
  
}

pyvolve_DF <- data.frame(pyvolve_DF,sq_hs_vec)

# The SQ of S/T-x-x-E is 0.17. This is the minimal SQ requirement. We do not want cases where the ancestral sequence was not phosphorylated by CK2 but the later descendants are. So, we filter out cases where the ancestor was probably not phosphorylated by CK2 but evolved it at a later time point.

pyvolve_DF <- pyvolve_DF[!(pyvolve_DF[,11] < 0.17 & pyvolve_DF[,12] > 0.17),]

```

# Compare the SQ between the real and simulated sequences

```{r}

# What we want to do here is rerun the analysis but instead restricting to positions outside of D/E+1 and D/E+3.
# so that I am testing for selection on the 'secondary' specificity determinants only.

# Should be n=299

pyvolve_DF_orginal <- pyvolve_DF

pyvolve_DF <- pyvolve_DF[substr(pyvolve_DF[,6],8,8) %in% c('D','E') & substr(pyvolve_DF[,6],10,10) %in% c('D','E'),]

# SQ for a S/T-D/E-x-D/E peptide

base_score <- ED_weight('AAAAAASEAEAAA',csnk2_pwm) #0.306

pyvolve_DF <- pyvolve_DF[pyvolve_DF[,12] > base_score,]

#################

# Use bespoke ED weight for this analysis
# Negative charge scoring function

ED_weight <- function(psite,pwm) {
  
  neg_row <- apply(pwm[rownames(pwm) %in% c('D','E'),],2,sum)
  pwm <- pwm[!rownames(pwm) %in% c('D','E'),]
  pwm <- rbind(pwm,neg_row)
  rownames(pwm)[nrow(pwm)] <- 'DE'
  
  psite <- unlist(strsplit(psite,split=''))
  
  c=0
  min=0
  
  # Ignore the central residue and + 1 and + 3 (i.e. 7,8,10)
  for (i in c(1:6,9,11:13)) {
    
    aa <- psite[i]  
    if (aa %in% c('D','E')) {aa <- 'DE'}
    
    # Skip if the amino acid is not D or E
    if (!(aa %in% c('DE'))) {next}
    
    current <- pwm[rownames(pwm) %in% aa,i]
    c = c+current
  
  }
  
  maximum <- sum(pwm[rownames(pwm) == 'DE',][c(1:6,9,11:13)])
  mss = c/maximum
  
  return(unname(mss))
  
}

############

library(cowplot)

seq_files <- list.files("vertebrate_ensembl_seq_anc_ST")

mean_p_value_vec <- NULL
var_p_value_vec <- NULL

for (i in 1:nrow(pyvolve_DF)) {
  
  setwd("Pyvolve_real")
  
  print(i)
  
  accession <- pyvolve_DF[i,3]
  pos <- pyvolve_DF[i,4]
  root_seq <- as.character(pyvolve_DF[i,8])
  site_tag <- paste(accession,'_',pos,sep='')
  site_tag_grep <- paste(accession,'_',pos,'_',sep='')
  
  # outfile parameters
  
  root_seq <- as.character(pyvolve_DF[i,8])
  root_sq <- pyvolve_DF[i,11]
  root_age <- pyvolve_DF[i,10]
  root_taxon <- pyvolve_DF[i,9]
  hs_sq <- pyvolve_DF[i,12]
  
  # Move into the correct directory                  
                    
  new_direc <- paste(getwd(),'/',site_tag,'_pyvolve_results',sep='')
  setwd(new_direc)
  
  new_direc_files <- list.files()
  concat_files <- new_direc_files[grep('concat',new_direc_files)]
  
  if (length(concat_files) != 200) {stop()}
  
  ####### Calculate the SQ for the real sequences
  
  setwd("vertebrate_ensembl_seq_anc_ST")
  
  seq <- NULL
  seq_file <- seq_files[grep(site_tag_grep,seq_files)]
  seq <- read.fasta(seq_file, seqtype='AA')
  seq_names <- names(read.fasta(seq_file, seqtype='AA'))
  
  # Map between human and the alignment
  
  human_seq <- getSequence(seq[[1]])
  seq <- getSequence(seq)
  
  count = 0
  al_pos_vec <- NULL
  human_pos_vec <- NULL
  
  for (j in 1:length(human_seq)) {
    
    aa <- human_seq[j]
    al_pos <- j
    
    if (aa != '-') {count=count+1; human_pos <- count}
    if (aa == '-') {count=count; human_pos <- '-'}
    
    al_pos_vec <- c(al_pos_vec, al_pos)
    human_pos_vec <- c(human_pos_vec, human_pos)
    
  }
  
  human_map_df <- data.frame(al_pos_vec, human_pos_vec,stringsAsFactors = FALSE)
  
  human_map_phospho_al <- human_map_df[human_map_df[,2] == pos,1]
  
  human_map_phospho_flank_al <- human_map_df[match((pos-6):(pos+6),human_map_df[,2]),1]
  
  human_map_phospho_flank_al <- human_map_phospho_flank_al[!is.na(human_map_phospho_flank_al)]
  
  # Identify sequences without S/T
  
  real_msa <- read.fasta(seq_file, seqtype='AA')
  real_msa_ST <- real_msa[rapply(real_msa, function(x) x[human_map_phospho_al]) %in% c('S','T')]
  
  nonST_dex <- which(!rapply(seq, function(x) x[human_map_phospho_al]) %in% c('S','T'))
  nonST_species <- seq_names[nonST_dex]
  
  if (length(real_msa_ST) == 0) {stop()}
  
   seq_wind_list <- NULL  
    
   # Here we are taking the sequence window from -6 to +6 per sequence and not necessarily the positions that align with -6 to +6 in human
     
   for (j in 1:length(real_msa_ST)) {
     
     seq <- unlist(getSequence(real_msa_ST[j]))
     gap_dex <- grep('-',seq)
     non_gap_dex <- setdiff(1:length(seq),gap_dex) 
     flank_dex <- which(non_gap_dex == human_map_phospho_al)
    
     
     n6 <- non_gap_dex[flank_dex-6]
     n5 <- non_gap_dex[flank_dex-5]
     n4 <- non_gap_dex[flank_dex-4]  
     n3 <- non_gap_dex[flank_dex-3]  
     n2 <- non_gap_dex[flank_dex-2]
     n1 <- non_gap_dex[flank_dex-1]
    
     n0 <- non_gap_dex[flank_dex-0]
     
     p1 <- non_gap_dex[flank_dex+1]
     p2 <- non_gap_dex[flank_dex+2]
     p3 <- non_gap_dex[flank_dex+3]
     p4 <- non_gap_dex[flank_dex+4]
     p5 <- non_gap_dex[flank_dex+5]
     p6 <- non_gap_dex[flank_dex+6]
    
     # Represent missing amino acids by gaps
     
     if ((flank_dex-6) < 1) {n6 <- gap_dex[1]}
     if ((flank_dex-5) < 1) {n5 <- gap_dex[1]}
     if ((flank_dex-4) < 1) {n4 <- gap_dex[1]}
     if ((flank_dex-3) < 1) {n3 <- gap_dex[1]}
     if ((flank_dex-2) < 1) {n2 <- gap_dex[1]}
     if ((flank_dex-1) < 1) {n1 <- gap_dex[1]}
     
     if ((flank_dex+1) > length(non_gap_dex)) {p1 <- gap_dex[1]}
     if ((flank_dex+2) > length(non_gap_dex)) {p2 <- gap_dex[1]}
     if ((flank_dex+3) > length(non_gap_dex)) {p3 <- gap_dex[1]}
     if ((flank_dex+4) > length(non_gap_dex)) {p4 <- gap_dex[1]}
     if ((flank_dex+5) > length(non_gap_dex)) {p5 <- gap_dex[1]}
     if ((flank_dex+6) > length(non_gap_dex)) {p6 <- gap_dex[1]}
           
     seq_wind <- seq[c(n6,n5,n4,n3,n2,n1,n0,p1,p2,p3,p4,p5,p6)]
     seq_wind <- paste(seq_wind,collapse='')
     
     seq_wind_list <- c(seq_wind_list,list(seq_wind))
     
   }  
    
   names(seq_wind_list) <- names(real_msa_ST)
  
   seq <- seq_wind_list
   
  ####
  
  real_sq <- NULL

  for (k in 1:length(seq)) {
      
      target <- seq[[k]]
      
      target_sq <- ED_weight(target,csnk2_pwm)
      real_sq <- c(real_sq, target_sq)
      
  }
  
  # substract the base_score from the real_sq
  
  real_sq <- real_sq #- base_score
  
  
  ####### simulated results
  
  setwd(new_direc)
 
  
  mean_sim_sq <- NULL
  var_sim_sq <- NULL
  
  for (j in 1:length(concat_files)) {
    
    simulated_sq <- NULL
    
    seq <- getSequence(read.fasta(concat_files[j], seqtype='AA'))
    seq_names <- names(read.fasta(concat_files[j], seqtype='AA'))
    
    # Ignore sequences from species that were not phosphorylatable in the real data
    
    if (length(nonST_species) > 0) {seq <- seq[!seq_names %in% nonST_species]}
    
    for (k in 1:length(seq)) {
      
      target <- seq[[k]]
      target <- paste(seq[[k]], collapse='')
      
      gap_grep <- grep('_',unlist(strsplit(root_seq,split='')))
      
      if(length(gap_grep) > 0) {
        if(min(gap_grep) > 7) {target <- paste(target,paste(rep('_',length(gap_grep)),collapse=''),sep='')}
        if(min(gap_grep) < 7) {target <- paste(paste(rep('_',length(gap_grep)),collapse=''),target,sep='')}
      }
      
      target_sq <- ED_weight(target,csnk2_pwm)
      simulated_sq <- c(simulated_sq, target_sq)
      
    }
    
    simulated_sq <- simulated_sq #- base_score
    
    mean_sim_sq <- c(mean_sim_sq,mean(simulated_sq))
    var_sim_sq <- c(var_sim_sq,var(simulated_sq))
  }
   
  ###########
  
  mean_p_value <- length(which(mean_sim_sq >= mean(real_sq)))
  var_p_value <- length(which(var_sim_sq <= var(real_sq)))
  
  mean_p_value_vec <- c(mean_p_value_vec, mean_p_value)
  var_p_value_vec <- c(var_p_value_vec, var_p_value)
  
}

## append p values to pyvolve DF

x <- mean_p_value_vec/200
y <- p.adjust(x, method = 'BH', n = length(x))
pyvolve_DF_sup_fig_final <- cbind(pyvolve_DF,y)

x <- var_p_value_vec/200
y <- p.adjust(x, method = 'BH', n = length(x))
pyvolve_DF_sup_fig_final <- cbind(pyvolve_DF_sup_fig_final,y)

colnames(pyvolve_DF_sup_fig_final)[c(13,14)] <- c('Mean_pvalue_FDR','Var_pvalue_FDR')

###################

sig_m_sup <- length(which(pyvolve_DF_sup_fig_final[,13] < 0.05 & pyvolve_DF_sup_fig_final[,14] >= 0.05))/nrow(pyvolve_DF_sup_fig_final)
sig_v_sup <- length(which(pyvolve_DF_sup_fig_final[,13] >= 0.05 & pyvolve_DF_sup_fig_final[,14] < 0.05))/nrow(pyvolve_DF_sup_fig_final)
sig_m_v_sup <- length(which(pyvolve_DF_sup_fig_final[,13] < 0.05 & pyvolve_DF_sup_fig_final[,14] < 0.05))/nrow(pyvolve_DF_sup_fig_final)
non_sig_sup <- length(which(pyvolve_DF_sup_fig_final[,13] >= 0.05 & pyvolve_DF_sup_fig_final[,14] >= 0.05))/nrow(pyvolve_DF_sup_fig_final)

col1 <- c('high M \n low V','low V','high M', 'no difference')  
col2 <- c(sig_m_v_sup, sig_v_sup, sig_m_sup, non_sig_sup)

sim_df <- data.frame(col1,col2)
colnames(sim_df) <- c('class','fraction')

sim_df$class <- factor(sim_df$class, levels = c(c('high M \n low V','low V','high M', 'no difference')))

p <- ggplot(sim_df, aes(x=class, y=fraction, fill=class, width=.75)) + geom_bar(color='black', lwd=0, stat='identity', alpha=0.55) + scale_fill_manual(values = c('red','red','red','red'))

# Font
p <- p+theme_bw() + theme(text=element_text(family="Ubuntu Light", face="plain", size=15), panel.border = element_rect(color="black", size=1.2, linetype="solid"))+theme(legend.position="none")

# Ticks
p <- p+theme(axis.ticks.length=unit(-0.10, "cm"), axis.text.x = element_text(margin=unit(c(0.2,0.2,0.2,0.2), "cm")), axis.text.y = element_text(margin=unit(c(0.2,0.2,0.2,0.2), "cm")))
p <- p + ylab("") + xlab("") + ggtitle('')
p <- p+theme(axis.text.x=element_text(size=5),axis.text.y=element_text(size=7),axis.title.x=element_text(size=11,face="plain"),axis.title.y=element_text(size=8,face="plain",vjust=-10),plot.title=element_text(size=11.5,face='bold'))
p <- p+theme(plot.title = element_text(hjust = 0.5))
p <- p + theme(plot.margin = unit(c(0.75,0.3,0.2,0), "cm")) # t, r, b, l

sup_sim_p <- p

```


